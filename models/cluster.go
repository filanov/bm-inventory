// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster cluster
//
// swagger:model cluster
type Cluster struct {
	Base

	// Virtual IP used to reach the OpenShift cluster API
	// Format: hostname
	APIVip strfmt.Hostname `json:"apiVip,omitempty"`

	// The base domain of the cluster. All DNS records must be sub-domains of this base and include the cluster name.
	BaseDNSDomain string `json:"baseDnsDomain,omitempty"`

	// IP address block from which Pod IPs are allocated This block must not overlap with existing physical networks. These IP addresses are used for the Pod network, and if you need to access the Pods from an external network, configure load balancers and routers to manage the traffic.
	// Pattern: ^([0-9]{1,3}\.){3}[0-9]{1,3}\/[0-9]|[1-2][0-9]|3[0-2]?$
	ClusterNetworkCIDR string `json:"clusterNetworkCIDR,omitempty"`

	// The subnet prefix length to assign to each individual node. For example, if clusterNetworkHostPrefix is set to 23, then each node is assigned a /23 subnet out of the given cidr (clusterNetworkCIDR), which allows for 510 (2^(32 - 23) - 2) pod IPs addresses. If you are required to provide access to nodes from an external network, configure load balancers and routers to manage the traffic.
	// Maximum: 32
	// Minimum: 1
	ClusterNetworkHostPrefix int64 `json:"clusterNetworkHostPrefix,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty" gorm:"type:datetime"`

	// Virtual IP used internally by the cluster for automating internal DNS requirements
	// Format: hostname
	DNSVip strfmt.Hostname `json:"dnsVip,omitempty"`

	// hosts
	Hosts []*Host `json:"hosts" gorm:"foreignkey:ClusterID;association_foreignkey:ID"`

	// Virtual IP used for cluster ingress traffic
	// Format: hostname
	IngressVip strfmt.Hostname `json:"ingressVip,omitempty"`

	// install completed at
	// Format: date-time
	InstallCompletedAt strfmt.DateTime `json:"installCompletedAt,omitempty" gorm:"type:datetime;default:0"`

	// install started at
	// Format: date-time
	InstallStartedAt strfmt.DateTime `json:"installStartedAt,omitempty" gorm:"type:datetime;default:0"`

	// OpenShift cluster name
	Name string `json:"name,omitempty"`

	// OpenShift cluster version
	// Pattern: ^4\.\d$
	OpenshiftVersion string `json:"openshiftVersion,omitempty"`

	// The pull secret that obtained from the Pull Secret page on the Red Hat OpenShift Cluster Manager site
	PullSecret string `json:"pullSecret,omitempty" gorm:"type:varchar(4096)"`

	// The IP address pool to use for service IP addresses. You can enter only one IP address pool. If you need to access the services from an external network, configure load balancers and routers to manage the traffic.
	// Pattern: ^([0-9]{1,3}\.){3}[0-9]{1,3}\/[0-9]|[1-2][0-9]|3[0-2]?$
	ServiceNetworkCIDR string `json:"serviceNetworkCIDR,omitempty"`

	// SSH public key for debugging OpenShift nodes
	SSHPublicKey string `json:"sshPublicKey,omitempty" gorm:"type:varchar(1024)"`

	// status
	// Required: true
	// Enum: [insufficient ready error installing installed]
	Status *string `json:"status"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty" gorm:"type:datetime"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *Cluster) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 Base
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.Base = aO0

	// AO1
	var dataAO1 struct {
		APIVip strfmt.Hostname `json:"apiVip,omitempty"`

		BaseDNSDomain string `json:"baseDnsDomain,omitempty"`

		ClusterNetworkCIDR string `json:"clusterNetworkCIDR,omitempty"`

		ClusterNetworkHostPrefix int64 `json:"clusterNetworkHostPrefix,omitempty"`

		CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

		DNSVip strfmt.Hostname `json:"dnsVip,omitempty"`

		Hosts []*Host `json:"hosts"`

		IngressVip strfmt.Hostname `json:"ingressVip,omitempty"`

		InstallCompletedAt strfmt.DateTime `json:"installCompletedAt,omitempty"`

		InstallStartedAt strfmt.DateTime `json:"installStartedAt,omitempty"`

		Name string `json:"name,omitempty"`

		OpenshiftVersion string `json:"openshiftVersion,omitempty"`

		PullSecret string `json:"pullSecret,omitempty"`

		ServiceNetworkCIDR string `json:"serviceNetworkCIDR,omitempty"`

		SSHPublicKey string `json:"sshPublicKey,omitempty"`

		Status *string `json:"status"`

		UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.APIVip = dataAO1.APIVip

	m.BaseDNSDomain = dataAO1.BaseDNSDomain

	m.ClusterNetworkCIDR = dataAO1.ClusterNetworkCIDR

	m.ClusterNetworkHostPrefix = dataAO1.ClusterNetworkHostPrefix

	m.CreatedAt = dataAO1.CreatedAt

	m.DNSVip = dataAO1.DNSVip

	m.Hosts = dataAO1.Hosts

	m.IngressVip = dataAO1.IngressVip

	m.InstallCompletedAt = dataAO1.InstallCompletedAt

	m.InstallStartedAt = dataAO1.InstallStartedAt

	m.Name = dataAO1.Name

	m.OpenshiftVersion = dataAO1.OpenshiftVersion

	m.PullSecret = dataAO1.PullSecret

	m.ServiceNetworkCIDR = dataAO1.ServiceNetworkCIDR

	m.SSHPublicKey = dataAO1.SSHPublicKey

	m.Status = dataAO1.Status

	m.UpdatedAt = dataAO1.UpdatedAt

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m Cluster) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.Base)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		APIVip strfmt.Hostname `json:"apiVip,omitempty"`

		BaseDNSDomain string `json:"baseDnsDomain,omitempty"`

		ClusterNetworkCIDR string `json:"clusterNetworkCIDR,omitempty"`

		ClusterNetworkHostPrefix int64 `json:"clusterNetworkHostPrefix,omitempty"`

		CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

		DNSVip strfmt.Hostname `json:"dnsVip,omitempty"`

		Hosts []*Host `json:"hosts"`

		IngressVip strfmt.Hostname `json:"ingressVip,omitempty"`

		InstallCompletedAt strfmt.DateTime `json:"installCompletedAt,omitempty"`

		InstallStartedAt strfmt.DateTime `json:"installStartedAt,omitempty"`

		Name string `json:"name,omitempty"`

		OpenshiftVersion string `json:"openshiftVersion,omitempty"`

		PullSecret string `json:"pullSecret,omitempty"`

		ServiceNetworkCIDR string `json:"serviceNetworkCIDR,omitempty"`

		SSHPublicKey string `json:"sshPublicKey,omitempty"`

		Status *string `json:"status"`

		UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`
	}

	dataAO1.APIVip = m.APIVip

	dataAO1.BaseDNSDomain = m.BaseDNSDomain

	dataAO1.ClusterNetworkCIDR = m.ClusterNetworkCIDR

	dataAO1.ClusterNetworkHostPrefix = m.ClusterNetworkHostPrefix

	dataAO1.CreatedAt = m.CreatedAt

	dataAO1.DNSVip = m.DNSVip

	dataAO1.Hosts = m.Hosts

	dataAO1.IngressVip = m.IngressVip

	dataAO1.InstallCompletedAt = m.InstallCompletedAt

	dataAO1.InstallStartedAt = m.InstallStartedAt

	dataAO1.Name = m.Name

	dataAO1.OpenshiftVersion = m.OpenshiftVersion

	dataAO1.PullSecret = m.PullSecret

	dataAO1.ServiceNetworkCIDR = m.ServiceNetworkCIDR

	dataAO1.SSHPublicKey = m.SSHPublicKey

	dataAO1.Status = m.Status

	dataAO1.UpdatedAt = m.UpdatedAt

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with Base
	if err := m.Base.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAPIVip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterNetworkCIDR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterNetworkHostPrefix(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSVip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngressVip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstallCompletedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstallStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenshiftVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceNetworkCIDR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateAPIVip(formats strfmt.Registry) error {

	if swag.IsZero(m.APIVip) { // not required
		return nil
	}

	if err := validate.FormatOf("apiVip", "body", "hostname", m.APIVip.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateClusterNetworkCIDR(formats strfmt.Registry) error {

	if swag.IsZero(m.ClusterNetworkCIDR) { // not required
		return nil
	}

	if err := validate.Pattern("clusterNetworkCIDR", "body", string(m.ClusterNetworkCIDR), `^([0-9]{1,3}\.){3}[0-9]{1,3}\/[0-9]|[1-2][0-9]|3[0-2]?$`); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateClusterNetworkHostPrefix(formats strfmt.Registry) error {

	if swag.IsZero(m.ClusterNetworkHostPrefix) { // not required
		return nil
	}

	if err := validate.MinimumInt("clusterNetworkHostPrefix", "body", int64(m.ClusterNetworkHostPrefix), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("clusterNetworkHostPrefix", "body", int64(m.ClusterNetworkHostPrefix), 32, false); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateDNSVip(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSVip) { // not required
		return nil
	}

	if err := validate.FormatOf("dnsVip", "body", "hostname", m.DNSVip.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateHosts(formats strfmt.Registry) error {

	if swag.IsZero(m.Hosts) { // not required
		return nil
	}

	for i := 0; i < len(m.Hosts); i++ {
		if swag.IsZero(m.Hosts[i]) { // not required
			continue
		}

		if m.Hosts[i] != nil {
			if err := m.Hosts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hosts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateIngressVip(formats strfmt.Registry) error {

	if swag.IsZero(m.IngressVip) { // not required
		return nil
	}

	if err := validate.FormatOf("ingressVip", "body", "hostname", m.IngressVip.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateInstallCompletedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.InstallCompletedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("installCompletedAt", "body", "date-time", m.InstallCompletedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateInstallStartedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.InstallStartedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("installStartedAt", "body", "date-time", m.InstallStartedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateOpenshiftVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.OpenshiftVersion) { // not required
		return nil
	}

	if err := validate.Pattern("openshiftVersion", "body", string(m.OpenshiftVersion), `^4\.\d$`); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateServiceNetworkCIDR(formats strfmt.Registry) error {

	if swag.IsZero(m.ServiceNetworkCIDR) { // not required
		return nil
	}

	if err := validate.Pattern("serviceNetworkCIDR", "body", string(m.ServiceNetworkCIDR), `^([0-9]{1,3}\.){3}[0-9]{1,3}\/[0-9]|[1-2][0-9]|3[0-2]?$`); err != nil {
		return err
	}

	return nil
}

var clusterTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["insufficient","ready","error","installing","installed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeStatusPropEnum = append(clusterTypeStatusPropEnum, v)
	}
}

// property enum
func (m *Cluster) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updatedAt", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
